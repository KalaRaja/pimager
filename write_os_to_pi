#!/bin/bash

XZ_IMAGE=$(ls *xz 2>/dev/null)
IMAGE=${XZ_IMAGE/.xz/}
RAW_DEVICES=()

declare -A DEVICES
declare -A DEVICES_SELECTED
declare -A DEVICES_INFO

INCREMENTAL_HOSTNAME_STATUS=ON
CURRENT_HOSTNAME_INDEX=1
HOSTNAME_PREFIX=pi
MENU_ROWS=0
LOG_ROWS=0
LOGS=()

getSudo() {
    local error=$(sudo -v 2>&1) #ask for sudo password

    if ((  $? )); then
        LOGS+=("error 'root' password failed: $error")
    fi
}

printr() {
    # $1 message
    # $2 color
    # $3 type

    if [[ $3 == "menu" ]]; then
        MENU_ROWS=$((MENU_ROWS+1))
    elif [[ $3 == "log" ]]; then
        LOG_ROWS=$((LOG_ROWS+1))
    fi

    local color=0m
    if [[ $2 == "disable" ]]; then
        color=90m
    elif [[ $2 == "prompt" ]]; then
        color="1;34m"
    elif [[ $2 == "info" ]]; then
        color="1;32m"
    fi

    echo -e "\033[$color$1\033[0m"
}

getDeviceInfo() {
    sudo fdisk -l | grep "Disk $1:"
}

getUsbDevices() {
    RAW_DEVICES=()
    if [[ -n $(ls -l /dev/disk/by-id/usb* 2>/dev/null) ]]; then
        for device in `ls -l /dev/disk/by-id/usb* | grep "/[a-z]*$" | awk '{print $11}'`; do
            local cleanDeviceString=/dev/${device:(-3)}
            RAW_DEVICES+=($cleanDeviceString)
        done
    fi
}

processUsbDevices() {
    truncateHashMaps
    local count=1
    for device in ${RAW_DEVICES[@]}; do
        local deviceInfo=$(getDeviceInfo $device)
        if [[ -n $deviceInfo ]]; then
            DEVICES[$device]=$count # hashmap: key: menu index
            DEVICES_SELECTED[$device]=0 # hashmap: key: isSelected
            DEVICES_INFO[$device]=$deviceInfo
            count=$((count+1))
        fi
    done
}

truncateHashMaps() {
    for key in ${!DEVICES[@]}; do
        DEVICES[$key]=0
        DEVICES_SELECTED[$key]=0
        DEVICES_INFO[$key]=none
    done
}

toggleIncrementalHostnameStatus() {
    if [[ $INCREMENTAL_HOSTNAME_STATUS == ON ]]; then
        INCREMENTAL_HOSTNAME_STATUS=OFF
    else
        INCREMENTAL_HOSTNAME_STATUS=ON
    fi
}

showAvailableDisksOptions() {
    if isAvailable; then
        printr "  Select Device(s)" normal menu
        for deviceKey in ${!DEVICES[@]}; do
            if (( ${DEVICES[$deviceKey]} != 0)); then
                printr "    ${DEVICES[$deviceKey]}. ${DEVICES_INFO[$deviceKey]}" normal menu
            fi
        done
    fi
}

showGenericMenu() {
    printr "  Options" normal menu
    printr "    r. Refresh device list" normal menu
    printr "    w. Write image to selected device(s)" normal menu

    if isSingleSelected; then
        printr "    i. Toggle incremental hostname $INCREMENTAL_HOSTNAME_STATUS" normal menu
    else
        printr "    i. Toggle incremental hostname $INCREMENTAL_HOSTNAME_STATUS" disable menu

    fi  

    printr "    c. Cleanup" normal menu
    printr "    q. Quit" normal menu
}

showSelectedDisks() {
     if isSelected; then
        printr "  Selected Device(s)" normal menu
        for deviceKey in ${!DEVICES_SELECTED[@]}; do
            if [[ ${DEVICES_SELECTED[$deviceKey]} == 1 ]]; then
                printr "      ${DEVICES_INFO[$deviceKey]}" normal menu
            fi
        done
    fi
}

showMenu() {
    showAvailableDisksOptions
    printr "" normal menu 
    showSelectedDisks
    printr "" normal menu 
    showGenericMenu
    printr "" normal menu 
    printr "  Press a key" prompt menu

}

clearMenu() {
    for (( i=0 ; i<$MENU_ROWS ; i++ )); do
        tput cup i 0 && tput ed
    done
    MENU_ROWS=0
}

isSelected() {
    for deviceKey in ${!DEVICES_SELECTED[@]}; do
        if [[ ${DEVICES_SELECTED[$deviceKey]} == 1 ]]; then
            return 0
        fi
    done

    return 1
}

isAvailable() {
    for deviceKey in ${!DEVICES[@]}; do
        if [[ ${DEVICES[$deviceKey]} != 0 ]]; then
            return 0
        fi
    done

    return 1
}

isSingleSelected() {
    local count=0
    for deviceKey in ${!DEVICES_SELECTED[@]}; do
        if [[ ${DEVICES_SELECTED[$deviceKey]} == 1 ]]; then
            count=$((count+1))
        fi
    done
    
    if (( $count == 1 )); then
        return 0
    fi

    return 1
}

unpackArchive() {
    if [[ ! -e $IMAGE ]]; then
        if [[ -e $XZ_IMAGE ]]; then
            LOGS+=("info Unpacking $IMAGE")
            local error=$(xz -dk  $XZ_IMAGE 2>&1)

            if ((  $? )); then
                LOGS+=("error Could not unpack $IMAGE: $error")
            fi

        else
            LOGS+=("error No OS image found.")
        fi
    fi
}

writeImageTodisk() {
    LOGS+=("info Writing $IMAGE to $1")
    local error=0 #$(sudo dd if=$IMAGE of=$1 bs=16M 2>&1)

    if ((  $? )); then
        LOGS+=("error Could not write $IMAGE to $1: $error")
    fi

}

unmountAllDevicePartitions() {
   for i in $(lsblk -l | grep ${1:(-3)}[1-9] | awk '{print $1}'); do
        LOGS+=("info Unmounting /dev/$i");
        local error=$(sudo umount /dev/$i 2>&1)

        if ((  $? )); then
            LOGS+=("error Could not unmount /dev/$i: $error")
        fi
    done
}

createMountPoints() {
    LOGS+=("info Creating mount points");
    if [[ ! -e boot ]]; then
        local error=$(mkdir boot 2>&1)

        if ((  $? )); then
            LOGS+=("error Could not create mount point boot: $error")
        fi
    fi

    if [[ ! -e rootfs ]]; then
        local error=$(mkdir rootfs 2>&1)

        if ((  $? )); then
            LOGS+=("error Could not create mount point rootfs: $error")
        fi
    fi
}

mountPartitions() {
    LOGS+=("info Mouting $1");
    local error=$(sudo mount -t vfat "$1"1 boot 2>&1)

    if ((  $? )); then
        LOGS+=("error Could not mount $1 on boot: $error")
    fi
    
    error=$(sudo mount -t ext4 "$1"2  rootfs)

    if ((  $? )); then
        LOGS+=("error Could not mount $1 on rootfs: $error")
    fi
}

enableSSH() {
    LOGS+=("info Enabling SSH");
    local error=$(sudo touch boot/ssh 2>&1)

    if ((  $? )); then
        LOGS+=("error Could not enable SSH: $error")
    fi
}

addHostname() {
    LOGS+=("info Adding hostname $1");
    local error=$(sudo sed -i "s/raspberrypi/$1/" rootfs/etc/hostname 2>&1)
    if ((  $? )); then
        LOGS+=("error Could not enable SSH: $error")
    fi
}

copyPublicKey() {
    LOGS+=("info writing your public key");

    if [[ ! -e rootfs/home/pi/.ssh ]]; then
        local error=$(sudo mkdir -m 700 rootfs/home/pi/.ssh 2>&1)

        if ((  $? )); then
            LOGS+=("error Could not create .ssh directory: $error")
        fi
    fi

    if [[ -e rootfs/home/pi/.ssh ]]; then
        local error=$(sudo cp ~/.ssh/id_rsa.pub rootfs/home/pi/.ssh/authorized_keys 2>&1)

        if ((  $? )); then
            LOGS+=("error Could not copy public key: $error")
        fi

        error=$(sudo chown -R 1000:1000 rootfs/home/pi/.ssh)

        if ((  $? )); then
            LOGS+=("error Could not set correct owner of rootfs/home/pi/.ssh: $error")
        fi
    fi

    local error=$(sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' rootfs/etc/ssh/sshd_config 2>&1)

    if ((  $? )); then
            LOGS+=("error Could not set PasswordAuthentication field in rootfs/etc/ssh/sshd_config: $error")
    fi
}

unmountEjectDevice() {
    LOGS+=("info Unmounting and ejecting device $1")
    unmountAllDevicePartitions $1

    local error=$(sudo eject $1 2>&1)

    if ((  $? )); then
            LOGS+=("error Could not eject $1: $error")
    fi

}

cleanup() {
    LOGS+=("info Cleaning up")

    local error=$(rm -rf boot 2>&1)

    if ((  $? )); then
        LOGS+=("error Could not remove boot: $error")
    fi

    error=$(rm -rf )

     if ((  $? )); then
        LOGS+=("error Could not remove rootfs: $error")
    fi

    error=$(rm $IMAGE)

     if ((  $? )); then
        LOGS+=("error Could not remove boot: $IMAGE")
    fi
}

handleChoice() {
    if [[ -z $CHOICE ]]; then
        return 0
    elif [[ $CHOICE == 'r' ]]; then
        getUsbDevices &&
        processUsbDevices &&
        showScreen
        unset CHOICE
    elif [[ $CHOICE == 'i' ]]; then
        if isSingleSelected; then
            toggleIncrementalHostnameStatus &&
            clearMenu &&
            showMenu
            unset CHOICE
        fi
    elif [[ $CHOICE == 'c' ]]; then
        cleanup
        unset CHOICE
    elif (( $CHOICE >= 1 && $CHOICE <= ${#DEVICES[@]} )); then
        for deviceKey in ${!DEVICES[@]}; do
            if (( $CHOICE == ${DEVICES[$deviceKey]} )); then
                if (( ${DEVICES_SELECTED[$deviceKey]} == 0 )); then
                    DEVICES_SELECTED[$deviceKey]=1
                    showScreen
                fi
            fi
        done
        unset CHOICE
    elif [[  $CHOICE == 'w' ]]; then
        if [[ isSelected ]]; then
            unpackArchive
            createMountPoints
            local count=$CURRENT_HOSTNAME_INDEX
            for deviceKey in ${!DEVICES_SELECTED[@]}; do
                if [[ ${DEVICES_SELECTED[$deviceKey]} == 1 ]]; then
                    unmountAllDevicePartitions $deviceKey &&
                    writeImageTodisk $deviceKey &&
                    mountPartitions $deviceKey
                    enableSSH &&
                    addHostname $HOSTNAME_PREFIX$count &&
                    copyPublicKey &&
                    unmountEjectDevice $deviceKey
                    count=$((count+1))

                    if [[ $INCREMENTAL_HOSTNAME_STATUS == ON ]]; then
                        CURRENT_HOSTNAME_INDEX=$((CURRENT_HOSTNAME_INDEX+1))
                    fi
                fi
            done

            getUsbDevices &&
            processUsbDevices &&
            showScreen
        else
            echo "Nothing selected"
        fi

        unset CHOICE
    fi
}

tput reset

showScreen() {
    clearMenu &&
    showMenu
}

readInput() {
    local input="r"
    read -n 1 -s -t .1 input

    if [[ ! -z $input ]]; then
        CHOICE=$input
    fi
}

showLogs() {
    tput cup $((MENU_ROWS+1))

    for (( i=0 ; i<$LOG_ROWS ; i++)); do
        tput ed
    done

    LOG_ROWS=0

    for log in "${LOGS[@]}"; do
        printr "$log" info log
    done
}

getSudo &&
getUsbDevices &&
processUsbDevices &&
showScreen

while [[ $CHOICE != "q" ]]; do
    readInput
    handleChoice
    showLogs
done